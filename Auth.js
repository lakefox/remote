class Auth {
    #call(event, ...args) {
        if (this.events[event]) {
            for (let i = 0; i < this.events[event].length; i++) {
                this.events[event][i](...args);
            }
        }
    }
    constructor(ws, master = false) {
        this.events = {};
        let id;
        let connections = {};

        ws.addEventListener("open", () => {
            // Initiate the handshake
            // There should only ever be one connection on the websocket
            if (master) {
                send({ type: "connect" });
            }
        });

        let handler = (raw) => {
            console.log(raw.data);
            let data = JSON.parse(raw.data);
            if (data.type == "connect") {
                let connectionId = parseInt(Math.random() * 10000000);
                if (data.ident) {
                    // After you initiated the handshake they are asking you assign them an ID
                    send({
                        type: "id",
                        id: connectionId,
                    });
                } else {
                    // Someone else initiated the handshake
                    // Assign them an ID
                    send({
                        type: "id",
                        id: connectionId,
                    });
                    // Ask them to connect
                    send({ type: "connect", ident: true });
                }
                // Create the message handlers
                let socket = new Socket(ws, id, connectionId);
                // Name the connection with the ident if you initated or the connection ID
                // if they did
                connections[data.ident || connectionId] = {
                    socket,
                };
                this.#call("open", socket);
            } else if (data.type == "id") {
                // All ID's are generated by the other system
                id = data.id;
            }
        };
        ws.addEventListener("message", handler);

        ws.addEventListener("close", () => {
            this.#call("close");
        });

        function send(data) {
            ws.send(JSON.stringify(data));
        }

        this.close = () => {
            ws.addEventListener("message", handler);
            this.#call("close");
        };
    }
    on(event, cb) {
        if (!this.events[event]) {
            this.events[event] = [];
        }
        this.events[event].push(cb);
    }
}

function Socket(ws, id, connectId) {
    let events = {};
    let catchAll = () => {};
    let channels = {};
    let handler = (raw) => {
        let data = JSON.parse(raw.data);
        if (data.id == id && data.type == "data") {
            if (data.channel != undefined) {
                // forward channel message to correct channel
                channels[data.channel].forward(data.data.type, data.data.data);
            } else {
                call(data.data.type, data.data.data);
            }
        } else if (
            data.id == id &&
            data.type == "open" &&
            data.channel !== undefined
        ) {
            // Create channel
            let channel = new Channel();

            channel.emitter((type, data) => {
                this.emit(type, data, data.channel);
            });

            channels.push(channel);
            channels[data.channel] = channel;
            call("channel", channel);
        }
    };
    ws.addEventListener("message", handler);

    function call(event, ...args) {
        if (events[event]) {
            for (let i = 0; i < events[event].length; i++) {
                events[event][i](...args);
            }
        } else {
            catchAll(event, ...args);
        }
    }
    this.on = (event, cb) => {
        if (!events[event]) {
            events[event] = [];
        }
        events[event].push(cb);
    };

    this.createChannel = () => {
        let channelId = parseInt(Math.random() * 10000000);
        ws.send(
            JSON.stringify({
                type: "open",
                id: connectId,
                channel: channelId,
            })
        );
        // Create channel
        let channel = new Channel();

        channel.emitter((type, data) => {
            this.emit(type, data, channelId);
        });

        channels[channelId] = channel;
        return channel;
    };

    this.catch = (cA) => {
        catchAll = cA;
    };

    this.id = id;
    this.emit = (type, data, channel = undefined) => {
        ws.send(
            JSON.stringify({
                type: "data",
                id: connectId,
                channel,
                data: {
                    type,
                    data,
                },
            })
        );
    };

    this.close = () => {
        ws.addEventListener("message", handler);
        call("close");
    };
}

function Channel() {
    let events = {};
    let catchAll = () => {};
    let emitter;
    function call(event, ...args) {
        if (events[event]) {
            for (let i = 0; i < events[event].length; i++) {
                events[event][i](...args);
            }
        } else {
            catchAll(event, ...args);
        }
    }
    this.forward = (type, data) => {
        call(type, data);
    };
    this.emit = (type, data) => {
        emitter(type, data);
    };
    this.emitter = (cb) => {
        emitter = cb;
    };
    this.close;
    this.on = (event, cb) => {
        if (!events[event]) {
            events[event] = [];
        }
        events[event].push(cb);
    };
    this.catch = (cA) => {
        catchAll = cA;
    };
}

// let io = new Auth("url");

// io.on("open", (socket) => {
//     console.log("Connected");
//     socket.emit("hi", { data: "hi" });
//     socket.on("hi", ({ data }) => {
//         console.log(data);
//     });

//     let channel = socket.createChannel();

//     channel.emit("event", "message");

//     channel.on("event", (msg) => {
//         console.log(msg);
//     });

//     socket.on("close", ({ data }) => {
//         console.log(data.id, "has left");
//     });
// });

export { Auth };
