/**
 * The code defines a JavaScript class called Auth that handles WebSocket communication and allows for
 * event-based messaging and channel creation.
 * @param ws - The `ws` parameter is the WebSocket object that represents the connection to the server.
 * It is used to send and receive messages over the WebSocket connection.
 * @param id - The `id` parameter represents the unique identifier assigned to a connection or channel.
 * It is used to distinguish between different connections or channels when sending and receiving data.
 * @param connectId - The `connectId` parameter is a unique identifier for the connection. It is used
 * to distinguish between different connections on the websocket.
 */
export class Auth {
    #call(event, ...args) {
        if (this.events[event]) {
            for (let i = 0; i < this.events[event].length; i++) {
                this.events[event][i](...args);
            }
        }
    }
    constructor(ws, master = false) {
        this.events = {};
        this.id;

        ws.addEventListener("open", () => {
            // Initiate the handshake
            // There should only ever be one connection on the websocket
            if (master) {
                send({ type: "connect" });
            }
        });
        let connectionId = parseInt(Math.random() * 10000000);
        let handler = (raw) => {
            let data = JSON.parse(raw.data);
            if (data.type == "connect") {
                if (data.ident) {
                    // After you initiated the handshake they are asking you assign them an ID
                    send({
                        type: "id",
                        id: connectionId,
                    });
                } else {
                    // Someone else initiated the handshake
                    // Assign them an ID
                    send({
                        type: "id",
                        id: connectionId,
                    });
                    // Ask them to connect
                    send({ type: "connect", ident: true });
                }
            } else if (data.type == "id") {
                // All ID's are generated by the other system
                this.id = data.id;
                // Create the message handlers
                let socket = new Socket(ws, this.id, connectionId);
                // Name the connection with the ident if you initated or the connection ID
                // if they did
                this.#call("open", socket, this.id);
            }
        };
        ws.addEventListener("message", handler);

        ws.addEventListener("close", () => {
            this.#call("close");
        });
        let closed = false;
        this.close = () => {
            ws.removeEventListener("message", handler);
            if (!closed) {
                closed = true;
                this.#call("close");
            }
        };
        let close = this.close;
        function send(data) {
            if (ws.readyState == 1) {
                ws.send(JSON.stringify(data));
            } else {
                close();
            }
        }
    }
    on(event, cb) {
        if (!this.events[event]) {
            this.events[event] = [];
        }
        this.events[event].push(cb);
    }
}

/**
 * The `Socket` function is a JavaScript class that represents a WebSocket connection and provides
 * methods for creating channels and emitting events.
 * @param ws - The `ws` parameter is the WebSocket object that represents the connection to the server.
 * It is used to send and receive messages over the WebSocket connection.
 * @param id - The `id` parameter represents the unique identifier for the socket. It is used to
 * identify the socket when sending and receiving data.
 * @param connectId - The `connectId` parameter is an identifier that represents the connection or
 * session ID for the socket. It is used to uniquely identify the socket connection and is typically
 * generated by the server when the socket connection is established.
 */
function Socket(ws, id, connectId) {
    let events = {};
    let catchAll = () => {};
    let handler = (raw) => {
        let data = JSON.parse(raw.data);
        if (data.id == id && data.type == "data") {
            if (data.channel == undefined) {
                call(data.data.type, data.data.data);
            }
        } else if (
            data.id == id &&
            data.type == "open" &&
            data.channel !== undefined
        ) {
            // Create channel
            let channel = new Channel(ws, id, connectId, data.channel);
            call("channel", channel);
        }
    };
    ws.addEventListener("message", handler);
    ws.addEventListener("close", () => {
        call("close");
    });

    function call(event, ...args) {
        if (events[event]) {
            for (let i = 0; i < events[event].length; i++) {
                events[event][i](...args);
            }
        } else {
            catchAll(event, ...args);
        }
    }
    this.on = (event, cb) => {
        if (!events[event]) {
            events[event] = [];
        }
        events[event].push(cb);
    };

    this.createChannel = () => {
        let channelId = parseInt(Math.random() * 10000000);
        if (ws.readyState == 1) {
            ws.send(
                JSON.stringify({
                    type: "open",
                    id: connectId,
                    channel: channelId,
                })
            );
        } else {
            this.close();
        }

        // Create channel
        let channel = new Channel(ws, id, connectId, channelId);
        return channel;
    };

    this.catch = (cA) => {
        catchAll = cA;
    };

    this.id = connectId;
    this.emit = (type, data) => {
        if (ws.readyState == 1) {
            ws.send(
                JSON.stringify({
                    type: "data",
                    id: connectId,
                    data: {
                        type,
                        data,
                    },
                })
            );
        } else {
            this.close();
        }
    };

    let closed = false;
    this.close = () => {
        ws.removeEventListener("message", handler);
        if (!closed) {
            closed = true;
            call("close");
        }
    };
}

/**
 * The `Channel` function is a JavaScript constructor that creates a communication channel between a
 * WebSocket connection and a specific channel, allowing for event-based communication.
 * @param ws - The `ws` parameter is a WebSocket object that represents the connection to a WebSocket
 * server. It is used to send and receive messages over the WebSocket connection.
 * @param id - The `id` parameter represents the unique identifier for the channel. It is used to
 * identify the channel when receiving messages from the WebSocket connection.
 * @param connectId - The `connectId` parameter is an identifier that represents the connection or
 * session ID. It is used to identify the specific connection or session associated with the channel.
 * @param channel - The `channel` parameter represents the name or identifier of the channel that the
 * `Channel` object is associated with. It is used to filter and handle specific events related to that
 * channel.
 */
function Channel(ws, id, connectId, channel) {
    let events = {};
    let catchAll = () => {};
    function call(event, ...args) {
        if (events[event]) {
            for (let i = 0; i < events[event].length; i++) {
                events[event][i](...args);
            }
        } else {
            catchAll(event, ...args);
        }
    }

    let handler = (raw) => {
        let data = JSON.parse(raw.data);
        if (data.id == id && data.type == "data" && data.channel == channel) {
            call(data.data.type, data.data.data);
        }
    };
    ws.addEventListener("message", handler);
    ws.addEventListener("close", () => {
        call("close");
    });
    this.id = channel;
    this.emit = (type, data) => {
        if (ws.readyState == 1) {
            ws.send(
                JSON.stringify({
                    type: "data",
                    id: connectId,
                    channel,
                    data: {
                        type,
                        data,
                    },
                })
            );
        } else {
            this.close();
        }
    };
    let closed = false;
    this.close = () => {
        ws.removeEventListener("message", handler);
        if (!closed) {
            closed = true;
            call("close");
        }
    };
    this.on = (event, cb) => {
        if (!events[event]) {
            events[event] = [];
        }
        events[event].push(cb);
    };
    this.catch = (cA) => {
        catchAll = cA;
    };
}

// let io = new Auth("url");

// io.on("open", (socket) => {
//     console.log("Connected");
//     socket.emit("hi", { data: "hi" });
//     socket.on("hi", ({ data }) => {
//         console.log(data);
//     });

//     let channel = socket.createChannel();

//     channel.emit("event", "message");

//     channel.on("event", (msg) => {
//         console.log(msg);
//     });

//     socket.on("close", ({ data }) => {
//         console.log(data.id, "has left");
//     });
// });
